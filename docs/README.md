# Менеджер задач

### 1. Назначение
Менеджер задач выполняет следующие задачи:
 - мониторинг выполнения задач
 - отправка задач соответствующим функциональным службам
 - получение информационных сообщений от функциональных служб
 - получение сообщений об окончании выполнения задач от функциональных служб
 - получение сообщений от функциональных служб на создание дочерних задач в текущей задачи
 - обновление статусов выполнения задач в зависимости от ответа функциональной службы
 - мониторинг работоспособности функциональных служб
 - перезапуск функциональных служб
 - перезапуск задач при восстановлении работоспособности функциональной службы
 
### 2. Структура базы данных

|          Наименование          |        Сущность       | Назначение |
| ------------------------------ | --------------------- | ---------- |
| Базовые задачи                 | manager.base_task     | Список базовых задач, которые могут быть поставлены |
| Задачи                         | manager.task          | Перечень подзадач |
| Последовательность задач       | manager.task_sequence | Перечень подзадач с привязкой к базовой задаче |
| Службы                         | manager.module        | Перечень функциональных служб, которые могут работать в данной системе |
| Методы функциональных служб    | manager.method_module | Перечень методов, которые предоставляют функциональные службы в данной системе |
| Операции                       | manager.action        | Перечень типовых операций задачи и сопоставление их с методом, с помощью которого данная операция выполняется функциональной службой |
| Команды                        | manager.command       | Перечень типовых команд, которые функциональные службы могут запросить у менеджера задач с сопоставление их с методом, с помощью которого данная команда выполняется функциональной службой (другой или текущей) |
| Аудит выполнения базовых задач | manager.main_task_log | Базовые задачи, поставленные на выполнение |
| Аудит выполнения задач         | manager.task_log      | Журналирование выполнения подзадач в поставленной базовой задаче |
| Аудит выполнения команд        | manager.command_log   | Журналирование выполнения команд подзадачи |
| Связь Аудита выполнения задачи с записью объекта | manager.object_to_task_log | Сопоставление выполняемой/выполненной задачи с объектом, который появился в результате выполнения задачи |
| Связь Аудита выполнения команд с записью объекта | manager.object_to_command_log | Сопоставление выполняемой/выполненной команды с объектом, который появился в результате выполнения команды |
| Сообщения                      | manager.message                | Перечень сообщений, которые появляются в результате взаимодействия менеджера задач с функциональными службами. Функциональные службы не порождают notify, а производят записи в данном информационном ресурсе, которые отлавливает менеджер задач |
| Статус выполнения задачи       | manager.task_completion_status | Статусы для инициирования и логирования выполнения задач |


### 3. Программная реализация
#### 3.1 Базовый класс службы
Базовый класс **BaseSVC** реализует общие для служб функции:
 - Подписка на канал
 - Выполнение задач в однопоточном или многопоточном режиме 
   с одной/несколькими очередями
 - Выполнение периодической и/или первичной задачи по условию

#### 3.2 Базовый класс функциональной службы
Базовый класс функциональной службы **BaseFunctionalSVC** является 
наследником класса BaseSVC и реализует (или перегружает) 
следующие свойства и методы:
 - подписка на канал, который прописан в базе данных в сущности 
   «*Службы*» для соответствующей функциональной службы
 - уведомление менеджера задач о начале работы при первичном запуске 
   или при получении запроса о работоспособности (тип сообщения: 
   «*Подключение*»). Выполняется посредством создания в сущности 
   «*Сообщения*» записи с атрибутами:
    - Родительское сообщение: <идентификатор сообщения с запросом о подключении> 
                              или null
    - Тип сообщения: Подключение
    - Отправитель: <наименование функциональной службы>
    - Получатель: Менеджер задач
    - Дата создания: <текущее время>
    - Статус: Отправлено
 - при получении задачи (тип сообщения: «*Задача*»):
    - обработка сообщения (предполагается, что сообщение – это json, 
      преобразованный в строку)
    - получение метода из сообщения (обязательный атрибут сообщения; 
      если его нет, то отправляется ответ об ошибке)
    - поиск соответствующего метода в классе
    - запуск метода класса с пришедшими остальными данными
    
#### 3.3 Буфер сообщений
Класс буфера сообщений **NotifyCount** производит оценку количества 
пришедших сообщений и времени, прошедшего с появления первого сообщения. 
Данный функционал предотвращает складывание задачи в очередь задач 
на каждое изменение в сущности.

### 4. Декораторы
#### 4.1 Декоратор для метода
Декоратор **task_wrapper** изменяет статус отправки родительской записи 
из сущности «*Сообщения*» и создает запись в сущность «*Сообщения*» 
в зависимости от приходящих данных и результата выполнения декорируемой 
функции. 

Для того чтобы декоратор исполнял свое назначение необходимо, 
чтобы декорируемая функция имела следующие именованные аргументы:
 - task – идентификатор записи из сущности «*Сообщения*» 
   (не обязателен для сообщений о первичном подключении, в остальных 
   случаях обязателен)
 - msg_type – тип сообщения
 - sender – запись из сущности «*Службы*» для функциональной службы
 - recipient – запись из сущности «*Службы*» для менеджера задач

Так же необходимо, чтобы функция возвращала следующие данные:
 - результат функции (или None)
 - признак ошибки (логическая переменная)
 - данные в виде словаря с обязательным ключом message, предназначенное 
   для отображения информации в пользовательском интерфейсе. 
   Дополнительно может включать в себя другие ключи для использования 
   данной информации другими службами или в иных целях.

Декоратор выполняет следующие действия:
 - получение значений необходимых именованных аргументов
 - получение записи из сущности «Сообщения» по task, 
   если task не пустой
 - изменение статуса отправки данной записи на «Получено», 
   если она существует
 - выполнение декорируемой функции с заменой в task идентификатора 
   на запись из сущности «*Сообщения*», если task не пустой
 - получение результата выполнения декорируемой функции (функция должна 
   предусматривать полную обработку ошибок и не предполагать raise)
 - создание записи в сущности «*Сообщения*» в соответствии с типом 
   сообщения, признака ошибки и полученных данных со ссылкой 
   на родительскую запись из сущности «*Сообщения*» и на запись из 
   сущности «*Аудит выполнения задач*», ссылка на которую указана 
   в родительской записи из сущности «*Сообщения*», если родительская 
   запись существует
 - изменение статуса отправки родительской записи из сущности 
   «*Сообщения*» на «*Отработано*» не зависимо от того, с ошибкой ли 
   выполнилась декорируемая функция или нет
   
#### 4.2 Декоратор для объекта в задаче
В базе данных предусмотрена связь задачи (как записи из сущности «*Аудит 
выполнения задач*») с объектом, создание которого произошло 
при выполнении данной задачи. Сущность «*Связь Аудита выполнения задач 
с объектом*» включает в себя ссылку на запись из сущности «*Аудит 
выполнения задач*» и идентификатор записи из другой сущности, 
как объекта. 

Декоратор **task_model_wrapper** реализует получение через цепочку 
«*Сообщение*» - «*Аудит выполнения задач*» - «*Связь Аудита выполнения 
задач с объектом*» экземпляра объекта с идентификатором, который указан 
в сущности «*Связь Аудита выполнения задач с объектом*» из той сущности, 
которая будет указана как аргумент декоратора. Аргументом декоратора 
должен быть класс, из которого посредством SQLAlchemy будет получен 
экземпляр записи. (**ПОСМОТРЕТЬ КАК РАБОТАТЬ С SQLAlchemy**)

Для того чтобы декоратор исполнял свое назначение необходимо, 
чтобы декорируемая функция имела следующие именованные аргументы:
 - task – запись из сущности «*Сообщения*»
Так же необходимо, чтобы функция возвращала следующие данные:
 - результат функции (или None)
 - признак ошибки (логическая переменная)
 - данные в виде словаря с обязательным ключом message, предназначенное 
   для отображения информации в пользовательском интерфейсе. 
   Дополнительно может включать в себя другие ключи для использования 
   данной информации другими службами или в иных целях.

Декоратор выполняет следующие действия:
 - получение значений необходимых именованных аргументов
 - получение записи из сущности «*Связь Аудита выполнения задачи с 
   записью объектом*» 
 - если ни одной записи не существует, то декоратор возвращает кортеж: 
    - None (результат функции)
    - True (признак ошибки)
    - {message:<message>} (данные в виде словаря)
 - иначе производит поиск в сущности (указана в аргументе декоратора) 
   записей с идентификаторами равному атрибуту «*Объект*» из сущности 
   «*Связь Аудита выполнения задач с записью объектом*»
 - если данных записей не существует, то декоратор возвращает кортеж: 
    - None (результат функции)
    - True (признак ошибки)
    - {message:<message>} (данные в виде словаря)
 - иначе вызывает декорируемую функцию, добавляя именованный аргумент 
   object_list, который равен полученному списку записей 
   (таким образов в декорируемой функции можно использовать данный 
   аргумент)
 - возврат ответа декорируемой функции

#### 4.3 Декоратор для объекта в команде
В базе данных предусмотрена связь команды (как записи из сущности 
«*Аудит выполнения команд*») с объектом, для которого данную команду 
необходимо выполнить. Сущность «*Связь Аудит выполнения команд с 
объектом*» включает в себя ссылку на запись из сущности «*Аудит 
выполнения команд*» и идентификатор записи из сущности («*Объект*»). 

Декоратор **command_model_wrapper** реализует получение через цепочку 
«*Сообщение*» - «*Аудит выполнения команд*» - «*Связь Аудит выполнения 
команд с объектом*» экземпляра объекта с идентификатором, который указан 
в сущности «*Связь Аудит выполнения команд с объектом*» из той сущности, 
которая будет указана как аргумент декоратора. Аргументом декоратора 
должна быть модель, из которой посредством SQLAlchemy будет получен 
экземпляр записи.

Для того чтобы декоратор исполнял свое назначение необходимо, чтобы 
декорируемая функция имела следующие именованные аргументы:
 - task – экземпляр записи из сущности «*Сообщения*»
Так же необходимо, чтобы функция возвращала следующие данные:
 - результат функции (или None)
 - признак ошибки (логическая переменная)
 - данные в виде словаря с обязательным ключом message, предназначенное 
   для отображения информации в пользовательском интерфейсе. 
   Дополнительно может включать в себя другие ключи для использования 
   данной информации другими службами или в иных целях.

Декоратор выполняет следующие действия:
 - получение значений необходимых именованных аргументов
 - получение записи из сущности «Связь Аудита выполнения команд 
   с объектом» 
 - если данной записи не существует или их несколько, то декоратор 
   возвращает кортеж: 
    - None (результат функции)
    - True (признак ошибки)
    - {message:<message>} (данные в виде словаря)
 - иначе производит поиск в модели (указана в аргументе декоратора) 
   записи с идентификатором равному атрибуту «*Объект*» из сущности 
   «*Связь Аудит выполнения команд с объектом*»
 - если данной записи не существует, то декоратор возвращает кортеж: 
    - None (результат функции)
    - True (признак ошибки)
    - {message:<message>} (данные в виде словаря)
 - иначе вызывает декорируемую функцию, добавляя именованный аргумент 
   related_object, который равен полученному экземпляру записи (таким образов 
   в декорируемой функции можно использовать данный аргумент)
 - возврат ответа декорируемой функции

#### 4.4 Декоратор для логирования в файл
Декоратор **logger** реализует запись в syslog результатов выполнения 
декорируемой функции. Аргументом декоратора является строка, 
определяющая тэг модуля.

Для того чтобы декоратор исполнял свое назначение необходимо, чтобы 
декорируемая функция возвращала следующие данные:
 - результат функции (или None)
 - признак ошибки (логическая переменная)
 - данные в виде словаря с обязательным ключом message, 
   предназначенное для отображения информации в пользовательском 
   интерфейсе. Дополнительно может включать в себя другие ключи 
   для использования данной информации другими службами или в иных целях.

Декоратор выполняет следующие действия:
 - выполнение декорируемую функцию, которая обернута в try 
   для логирования необработанных ошибок
 - если возникает ошибка при выполнении функции, тогда в syslog 
   записывается текст ошибки, включая traceback, с тегом, 
   указанным в аргументе декоратора, далее декоратор возвращает кортеж:
    - None (результат функции)
    - True (признак ошибки)
    - {message:<message>} (данные в виде словаря)
 - иначе если признак ошибки, который вернула функция положительный, 
   тогда в syslog записывается текст ошибки (ключ message)
 - если признак ошибки отрицательный, тогда в syslog записывается текст 
   об успешном выполнении функции (ключ message)
 - возврат ответа декорируемой функции

#### 4.5 Декоратор для логирования в базу данных
Декоратор **info_logger** реализует создание информационной записи 
в сущности «*Сообщения*» результатов выполнения декорируемой функции.

Для того чтобы декоратор исполнял свое назначение необходимо, чтобы 
декорируемая функция имела следующие именованные аргументы:
 - task – экземпляр записи из сущности «*Сообщения*»
Так же необходимо, чтобы функция возвращала следующие данные:
 - результат функции (или None)
 - признак ошибки (логическая переменная)
 - данные в виде словаря с обязательным ключом message, предназначенное 
   для отображения информации в пользовательском интерфейсе. 
   Дополнительно может включать в себя другие ключи для использования 
   данной информации другими службами или в иных целях.

Декоратор выполняет следующие действия:
 - получение значений необходимых именованных аргументов
 - выполнение декорируемой функции
 - если признак ошибки, который вернула функция отрицательный, и 
   существуют данные (data), тогда
 - в поле data производится поиск поля тип сообщения (msg_type)
 - если поля не существует, то создается запись в сущности «*Сообщения*» 
   с типом «*Информация*»
 - иначе создается запись в сущности «*Сообщения*» с указанным типом 
   (например «*Внимание*»)
 - возврат ответа декорируемой функции
    
   